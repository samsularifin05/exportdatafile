{"version":3,"sources":["../src/interface.ts","../src/helpers.ts","../src/exportTextFile.tsx","../src/index.ts"],"names":["validFileTypes","convertDateTime","tgl","isDateTime","date","jakartaDate","year","month","day","hours","minutes","seconds"],"mappings":"AAkCO,qxBAAMA,CAAAA,CAA6B,CAAC,OAAA,CAAS,KAAA,CAAO,KAAA,CAAO,KAAK,CAAA,CC/BhE,SAASC,CAAAA,CAAgBC,CAAAA,CAAaC,CAAAA,CAAsB,CAAA,CAAA,CAAO,CACxE,IAAMC,CAAAA,CAAO,IAAI,IAAA,CAAKF,CAAG,CAAA,CAGnBG,CAAAA,CAAc,IAAI,IAAA,CAAKD,CAAAA,CAAK,OAAA,CAAQ,CAAA,CAAI,GAAA,CAAS,EAAA,CAAK,GAAI,CAAA,CAE1DE,CAAAA,CAAOD,CAAAA,CAAY,cAAA,CAAe,CAAA,CAClCE,CAAAA,CAAQ,MAAA,CAAOF,CAAAA,CAAY,WAAA,CAAY,CAAA,CAAI,CAAC,CAAA,CAAE,QAAA,CAAS,CAAA,CAAG,GAAG,CAAA,CAC7DG,CAAAA,CAAM,MAAA,CAAOH,CAAAA,CAAY,UAAA,CAAW,CAAC,CAAA,CAAE,QAAA,CAAS,CAAA,CAAG,GAAG,CAAA,CACtDI,CAAAA,CAAQ,MAAA,CAAOJ,CAAAA,CAAY,WAAA,CAAY,CAAC,CAAA,CAAE,QAAA,CAAS,CAAA,CAAG,GAAG,CAAA,CACzDK,CAAAA,CAAU,MAAA,CAAOL,CAAAA,CAAY,aAAA,CAAc,CAAC,CAAA,CAAE,QAAA,CAAS,CAAA,CAAG,GAAG,CAAA,CAC7DM,CAAAA,CAAU,MAAA,CAAON,CAAAA,CAAY,aAAA,CAAc,CAAC,CAAA,CAAE,QAAA,CAAS,CAAA,CAAG,GAAG,CAAA,CAEnE,OAAOF,CAAAA,CACH,CAAA,EAAA;ACqEa;AAIa,GAAA;AACC;AAMd;AAAA;AAW0B;ACzEnB","file":"/Users/nagatech1/Project/exporter/exportdata-dev/dist/index.js","sourcesContent":["import jsPDF from \"jspdf\";\nimport ExcelJS from \"exceljs\";\n\ntype FormatType = \"RP\" | \"GR\" | \"DATETIME\" | \"DATE\" | \"NUMBER\" | \"IMAGE\" | \"\";\ntype HalignType = \"center\" | \"right\" | \"left\" | \"\";\ntype ValignType = \"top\" | \"middle\" | \"bottom\" | undefined;\n\nexport interface ColumnGenarator<T> {\n  key: keyof T;\n  label?: string;\n  options?: {\n    format?: FormatType;\n    halign?: HalignType;\n    valign?: ValignType;\n    txtColor?: string;\n    bgColor?: string;\n    width?: number;\n    disabledColumn?: boolean;\n    disabledFooter?: boolean;\n  };\n  child?: ColumnGenarator<T>[];\n  formatter?: (cellValue: any, rowData: any) => any;\n}\n\nexport interface DataItemGenerator {\n  [key: string]: any;\n}\n\nexport type FileType = \"EXCEL\" | \"PDF\" | \"TXT\" | \"ALL\";\ntype GroupingStyle = {\n  txtColor?: string;\n  bgColor?: string;\n  halign?: \"left\" | \"right\" | \"center\";\n};\nexport const validFileTypes: FileType[] = [\"EXCEL\", \"PDF\", \"TXT\", \"ALL\"];\ntype CustomizePdfFunction = (\n  doc: jsPDF,\n  finalY: number,\n  autoTable?: any\n) => void;\ntype addRowPdfPdfFunction = (tableRows?: any) => void;\ntype CustomizeFunctionExcel = (\n  worksheet: ExcelJS.Worksheet,\n  lastIndex: number\n) => void;\ntype GroupingSettingType =\n  | GroupingStyle\n  | ((item: DataItemGenerator) => GroupingStyle);\nexport interface GenaratorExport<T> {\n  columns: ColumnGenarator<T>[];\n  data: DataItemGenerator[];\n  type: FileType[];\n  title?: string;\n  groupingSetting?: GroupingSettingType;\n\n  pdfSetting?: {\n    orientation?: \"p\" | \"portrait\" | \"l\" | \"landscape\";\n    unit?: \"pt\" | \"px\" | \"in\" | \"mm\" | \"cm\" | \"ex\" | \"em\" | \"pc\";\n    width?: number;\n    height?: number;\n    fontSIze?: number;\n    bgColor?: string;\n    titlePdf?: string;\n    txtColor?: string;\n    startY?: number;\n    header?: {\n      column?: boolean;\n      information?: boolean;\n    };\n    textHeaderRight?: string;\n    textHeaderLeft?: string;\n    theme?: \"grid\" | \"striped\" | \"plain\";\n    grandTotalSetting?: {\n      disableGrandTotal?: boolean;\n      colSpan?: number;\n    };\n    openNewTab?: boolean;\n    disablePrintDate?: boolean;\n    returnDataUri?: boolean;\n    addRow?: addRowPdfPdfFunction;\n    // customize?: CustomizePdfFunction;\n    customHeader?: CustomizePdfFunction;\n    customFooter?: CustomizePdfFunction;\n  };\n  date?: {\n    start_date?: string;\n    end_date?: string;\n    caption?: string;\n  };\n  txtSetting?: {\n    dataTxt?: DataItemGenerator | DataItemGenerator[];\n    titleTxt: string;\n    templateTxt?: string;\n    copy?: boolean;\n  };\n  excelSetting?: {\n    titleExcel?: string;\n    bgColor?: string;\n    startY?: number;\n    txtColor?: string;\n    additionalTextHeader?: string;\n    grandTotalSetting?: {\n      disableGrandTotal?: boolean;\n      colSpan?: number;\n    };\n    subTotal?: {\n      disableGrandTotal?: boolean;\n    };\n    returnBuffer?: boolean;\n    customHeader?: CustomizeFunctionExcel;\n    customFooter?: CustomizeFunctionExcel;\n  };\n  grouping: string[];\n  footerSetting?: {\n    subTotal?: {\n      caption?: string;\n      disableSubtotal?: boolean;\n      enableCount?: boolean;\n      captionItem?: string;\n    };\n    grandTotal?: {\n      caption?: string;\n      disableGrandTotal?: boolean;\n      captionItem?: string;\n      enableCount?: boolean;\n    };\n  };\n}\n","import ExcelJS from \"exceljs\";\nimport { ColumnGenarator, FileType, validFileTypes } from \"./interface\";\n\nexport function convertDateTime(tgl: string, isDateTime: boolean = false) {\n  const date = new Date(tgl);\n\n  // Tambahkan offset 7 jam (WIB)\n  const jakartaDate = new Date(date.getTime() + 7 * 60 * 60 * 1000);\n\n  const year = jakartaDate.getUTCFullYear();\n  const month = String(jakartaDate.getUTCMonth() + 1).padStart(2, \"0\");\n  const day = String(jakartaDate.getUTCDate()).padStart(2, \"0\");\n  const hours = String(jakartaDate.getUTCHours()).padStart(2, \"0\");\n  const minutes = String(jakartaDate.getUTCMinutes()).padStart(2, \"0\");\n  const seconds = String(jakartaDate.getUTCSeconds()).padStart(2, \"0\");\n\n  return isDateTime\n    ? `${day}-${month}-${year} ${hours}:${minutes}:${seconds}`\n    : `${day}-${month}-${year}`;\n}\n\nexport function validateFileTypes(fileTypes: FileType[]): boolean {\n  return fileTypes.every((fileType) => validFileTypes.includes(fileType));\n}\n\nexport function countColumns(columns: ColumnGenarator<any>[]): number {\n  let count = 0;\n  columns.forEach((col) => {\n    if (col.child && col.child.length > 0) {\n      count += countColumns(col.child);\n    } else {\n      count += 1;\n    }\n  });\n  return count;\n}\n\nexport const getFlattenColumns = (\n  columns: ColumnGenarator<any>[]\n): ColumnGenarator<any>[] => {\n  const flat: ColumnGenarator<any>[] = [];\n\n  columns.forEach((col) => {\n    if (col.child && col.child.length > 0) {\n      flat.push(...getFlattenColumns(col.child)); // panggil rekursif\n    } else {\n      flat.push(col);\n    }\n  });\n\n  return flat;\n};\n\nexport const formatingTitle = (title: string): string => {\n  // Pisahkan kata-kata menggunakan underscore sebagai pemisah\n  const words = title.split(\"_\");\n\n  // Ubah setiap kata menjadi huruf kapital dan gabungkan kembali dengan spasi di antara mereka\n  const formattedtitle = words\n    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))\n    .join(\" \");\n\n  return formattedtitle;\n};\n\n/**\n * Menambahkan gambar ke baris Excel menggunakan ExcelJS di browser, dari base64 string\n */\nexport async function addImagesToRow(\n  workbook: ExcelJS.Workbook,\n  worksheet: ExcelJS.Worksheet,\n  row: ExcelJS.Row,\n  rowData: any[]\n) {\n  for (let index = 0; index < rowData.length; index++) {\n    const cellData = rowData[index];\n\n    // Proses jika imageSrc adalah base64 string\n    if (\n      cellData?.isImage &&\n      cellData?.imageSrc &&\n      typeof cellData.imageSrc === \"string\" &&\n      cellData.imageSrc.startsWith(\"data:image\")\n    ) {\n      try {\n        const { buffer, extension } = base64ToBufferAndExtension(\n          cellData.imageSrc\n        );\n\n        const imageId = workbook.addImage({\n          buffer: buffer as any,\n          extension,\n        });\n\n        worksheet.addImage(imageId, {\n          tl: { col: index, row: row.number - 1 },\n          ext: { width: 70, height: 60 },\n          editAs: \"oneCell\",\n        });\n\n        if (!row.height || row.height < 60) {\n          row.height = 35;\n        }\n      } catch (error) {\n        console.error(\"âŒ Error adding image to row:\", error);\n        row.getCell(index + 1).value = \"[Image]\";\n      }\n    }\n  }\n}\n\n/**\n * Mengubah base64 image string ke buffer dan extension\n */\nfunction base64ToBufferAndExtension(base64: string): {\n  buffer: Uint8Array;\n  extension: any;\n} {\n  const match = base64.match(/^data:image\\/(\\w+);base64,(.*)$/);\n  if (!match) throw new Error(\"Invalid base64 image format\");\n  const extension = match[1] === \"jpg\" ? \"jpeg\" : (match[1] as any);\n  const base64Data = match[2];\n  const binaryString = atob(base64Data);\n  const len = binaryString.length;\n  const bytes = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n  return { buffer: bytes, extension };\n}\n\nexport const convertArgbToRgb = (color: string): string => {\n  if (!color) return color;\n\n  // Remove # if present\n  const cleanColor = color.replace(/^#/, \"\");\n\n  // If 8 characters (ARGB), strip first 2 characters (alpha channel)\n  if (cleanColor.length === 8) {\n    return cleanColor.substring(2);\n  }\n\n  // If already 6 characters (RGB) or 3 characters (short RGB), return as is\n  return cleanColor;\n};\n","interface Load {\n  [key: string]: string | string[] | undefined;\n}\n\ninterface Res {\n  data: Load[];\n  template: string;\n  copy?: boolean;\n}\n\nconst generateNotaSlip = (res: Res): string[] => {\n  const notaGenerated: string[] = [];\n  const jml = res.copy ? 2 : 1;\n  for (let index = 0; index < jml; index++) {\n    const nota: string[] = res.data.map((load: Load) => {\n      let replaceLoop = res.template;\n\n      while (/\\n!!LOOP\\((.+)\\)(\\{\\n(.*\\n)+\\})\\n/gm.exec(replaceLoop)) {\n        replaceLoop = replaceLoop.replace(\n          /\\n!!LOOP\\((.+)\\)(\\{\\n(.*\\n)+\\})\\n/,\n          (_match, p1, p2) => {\n            const loopContent = p2.replace(/^\\{/, \"\").replace(/\\}$/, \"\");\n            const loopArray: string[] | undefined = !Array.isArray(load[p1])\n              ? [load[p1] as string]\n              : (load[p1] as string[]);\n            const detail: string = loopArray.reduce((acc, val) => {\n              return (\n                acc +\n                loopContent.replace(/\\{([a-z0-9_]+)\\}/gm, (c: any) => {\n                  const key = c.replace(/(\\{|\\})/g, \"\");\n                  if (key.match(/nama_barang/)) {\n                    const keyCustomer = key.match(/nama_barang/);\n                    const sliceNamaBarang =\n                      key === \"nama_barang2\"\n                        ? [20, 40]\n                        : key === \"nama_barang3\"\n                        ? [40, 60]\n                        : [0, 20];\n                    return (\n                      (val[keyCustomer] as string)\n                        ?.slice(...sliceNamaBarang)\n                        .trim() || \"\"\n                    );\n                  }\n                  if (key.match(/deskripsi_jual/)) {\n                    const keyDeskripsi = key.match(/deskripsi_jual/);\n                    const sliceDeskripsi =\n                      key === \"deskripsi_jual2\"\n                        ? [20, 40]\n                        : key === \"deskripsi_jual3\"\n                        ? [40, 60]\n                        : [0, 20];\n                    return (\n                      (val[keyDeskripsi] as string)\n                        ?.slice(...sliceDeskripsi)\n                        .trim() || \"\"\n                    );\n                  }\n                  if (key.match(/deskripsi/)) {\n                    const keyCustomer = key.match(/deskripsi/);\n                    const sliceNama =\n                      key === \"deskripsi2\"\n                        ? [20, 40]\n                        : key === \"deskripsi3\"\n                        ? [40, 60]\n                        : [0, 20];\n                    return (\n                      (val[keyCustomer] as string)\n                        ?.slice(...sliceNama)\n                        .trim() || \"\"\n                    );\n                  }\n                  return (val[key] as string) || \"\";\n                })\n              );\n            }, \"\");\n            return detail.replace(/\\n(\\s)+\\n/gm, \"\\n\");\n          }\n        );\n      }\n\n      return replaceLoop\n        .replace(/\\{([a-z0-9_]+)\\}/gm, (c) => {\n          const key = c.replace(/(\\{|\\})/g, \"\");\n\n          if (key.match(/auto_cut/)) {\n            return \"\\n\u001dVA\";\n          }\n          return (load[key] as string) || \"\";\n        })\n        .replace(/\\n(\\s)+\\n/gm, \"\\n\")\n        .replace(/~new_line~/gm, \"\\n\")\n        .replace(/!!LOOP\\(detail\\)/g, \"\")\n        .replace(/[}{]/g, \"\");\n    });\n\n    for (const key in nota) {\n      nota[key] += \"\\n\\n\";\n    }\n\n    notaGenerated.push(...nota);\n  }\n\n  return notaGenerated;\n};\n\nconst ExportToTxt = async (res: any, nama_file: string): Promise<void> => {\n  const notaGenerated = generateNotaSlip(res);\n  const blob = new Blob([notaGenerated?.join(\"\\n\") || \"\"], {\n    type: \"text/plain\"\n  });\n  const downloadLink = document.createElement(\"a\");\n  downloadLink.href = URL.createObjectURL(blob);\n  downloadLink.download = nama_file;\n  document.body.appendChild(downloadLink);\n  downloadLink.click();\n  document.body.removeChild(downloadLink);\n};\n\nexport default ExportToTxt;\n","import ExportExcel from \"./exportExcel\";\nimport ExportPDF from \"./exportPdf\";\nimport ExportToTxt from \"./exportTextFile\";\nimport { validateFileTypes } from \"./helpers\";\nimport { GenaratorExport, ColumnGenarator } from \"./interface\";\n\n/**\n * Ekspor ke PDF atau Excel berdasarkan konfigurasi yang diberikan.\n *\n * @param title - Judul laporan.\n * @param columns - Konfigurasi kolom untuk laporan.\n * @param data - Data yang akan disertakan dalam laporan.\n * @param grouping - Gruping yang akan diterapkan dalam laporan ada head dan detail Example: [\"no_faktur_hutang\"].\n * @param pdfSetting - Opsi untuk config PDF.\n * @param excelSetting - Opsi untuk config Excel.\n * @param txtSetting - Opsi untuk config Txt file.\n * @param date - Rentang tanggal untuk laporan.\n * @param type - Jenis laporan yang akan diekspor (\"PDF\" \"TXT\" atau \"EXCEL\").\n * @param footerSetting - Setting Footer Subtotal atau GranTotal\n */\nexport const ExportData = <T>({\n  columns,\n  data,\n  grouping,\n  date,\n  type,\n  txtSetting,\n  pdfSetting,\n  excelSetting,\n  title,\n  footerSetting,\n  groupingSetting,\n}: GenaratorExport<T>): void => {\n  const databaru = {\n    data: [txtSetting?.dataTxt],\n    template: txtSetting?.templateTxt,\n    copy: txtSetting?.copy,\n  };\n\n  if (data.length === 0) {\n    throw new Error(\"Data is required\");\n  }\n  if (type.length === 0) {\n    throw new Error(\"Type is required\");\n  }\n\n  if (!validateFileTypes(type)) {\n    throw new Error(`Type Export must use [\"EXCEL\", \"PDF\", \"TXT\", \"ALL\"]`);\n  }\n\n  type.forEach((list) => {\n    if (list === \"PDF\") {\n      ExportPDF({\n        pdfSetting,\n        date,\n        data,\n        type,\n        columns,\n        grouping,\n        title,\n        footerSetting,\n        groupingSetting,\n      });\n    } else if (list === \"TXT\") {\n      ExportToTxt(databaru, txtSetting?.titleTxt || \"\");\n    } else if (list === \"EXCEL\") {\n      ExportExcel({\n        date,\n        data,\n        type,\n        columns,\n        grouping,\n        excelSetting,\n        title,\n        footerSetting,\n        groupingSetting,\n      });\n    } else {\n      ExportExcel({\n        date,\n        data,\n        type,\n        columns,\n        grouping,\n        excelSetting,\n        title,\n        groupingSetting,\n      });\n\n      ExportPDF({\n        pdfSetting,\n        date,\n        data,\n        type,\n        columns,\n        grouping,\n        title,\n        groupingSetting,\n      });\n\n      ExportToTxt(databaru, txtSetting?.titleTxt || \"\");\n    }\n  });\n};\n\nexport type { ColumnGenarator };\n"]}